<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2019-02-19" />
  <title>Formal Languages &amp; Automata Theory</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Formal Languages &amp; Automata Theory</h1>
<p class="subtitle">Midterm Review</p>
<p class="date">February 19, 2019</p>
</header>
<h1 id="midterm-review">Midterm Review</h1>
<h2 id="topics-covered">Topics Covered</h2>
<ul>
<li>The midterm exam will cover Chapter 0 and Chapter 1
<ul>
<li>the material will especially focus on Chapter 1</li>
<li>However, Chapter 0 has foundation material from Discrete Mathematics with which you should be familiar.</li>
</ul></li>
</ul>
<h2 id="topics-not-on-exam">Topics Not on Exam</h2>
<ul>
<li>You will not have problems directly related to graphs (Covered in Section 0.2)</li>
<li>You will not have to <em>write</em> a proof (Section 0.4), though you should understand the theorems that have been proven in the textbook or in lecture</li>
<li>You will not have to use the Pumping Lemma to prove that a language is not regular, but you should understand the general idea and what its purpose is.</li>
</ul>
<h2 id="outline-of-notable-topics">Outline of Notable Topics</h2>
<ul>
<li>0.1
<ul>
<li>Automata Theory</li>
<li>Complexity Theory</li>
<li>Computability Theory</li>
</ul></li>
<li>0.2
<ul>
<li>Sets
<ul>
<li>Subsets</li>
<li>Intersection</li>
<li>Union</li>
<li>Complement</li>
<li>power set</li>
<li>Cartesian product / cross product</li>
</ul></li>
<li>Sequences</li>
<li>Tuples</li>
<li>Functions and Relations
<ul>
<li>Function</li>
<li>Domain</li>
<li>Range</li>
</ul></li>
<li>Strings and Languages
<ul>
<li>alphabet</li>
<li>symbols</li>
<li>a string over an alphabet</li>
<li>length</li>
<li>empty string</li>
<li>reverse</li>
<li>substring</li>
<li>concatenation</li>
</ul></li>
<li>Boolean Logic</li>
<li>Notation
<ul>
<li><span class="math inline">ℕ</span></li>
<li><span class="math inline">ℤ</span></li>
<li><span class="math inline"><em>ϵ</em></span></li>
<li><span class="math inline">∅</span></li>
<li><span class="math inline">∪</span></li>
<li><span class="math inline">∪</span></li>
<li><span class="math inline">⊂</span></li>
<li><span class="math inline">⊆</span></li>
<li><span class="math inline">⊃</span></li>
<li><span class="math inline">⊇</span></li>
<li><span class="math inline">×</span></li>
<li><span class="math inline">∈</span></li>
<li><span class="math inline">∉</span></li>
<li><span class="math inline"><em>Σ</em></span></li>
<li>|w|</li>
</ul></li>
<li>1.1
<ul>
<li>Definition 1.5 - finite automaton</li>
<li>Definition 1.16 - regular language</li>
<li>Definition 1.23 - Regular Operations of Languages
<ul>
<li>Union</li>
<li>Concatenation</li>
<li>Star</li>
</ul></li>
<li>states</li>
<li>transition function (<span class="math inline"><em>δ</em></span>)
<ul>
<li>understand how to document a transition function in three ways:
<ul>
<li>a list, e.g. () <span class="math inline"><em>δ</em></span> (A, 1) <span class="math inline">→</span> B, <span class="math inline"><em>δ</em></span> (A, 0) <span class="math inline">→</span> A, <span class="math inline"><em>δ</em></span> (B, 0) <span class="math inline">→</span> B, <span class="math inline"><em>δ</em></span> (B, 1) <span class="math inline">→</span> B )</li>
<li>or as a transition table,</li>
<li>or you can represent it in a state diagram</li>
</ul></li>
</ul></li>
<li>Notation
<ul>
<li><span class="math inline">∘</span></li>
<li><span class="math inline">∪</span></li>
<li><span class="math inline">*</span></li>
<li><span class="math inline"><em>δ</em></span></li>
</ul></li>
<li>Understand the complement of a language and the complement of a finite automata.</li>
</ul></li>
<li>1.2 Nondeterminism
<ul>
<li>Nondeterminism vs. determinism</li>
<li>Definition 1.37 - NFA</li>
<li>Theorem 1.39 - Equivalence of NFAs and DFAs</li>
<li>Corollary 1.40 - Regular Languages and NFAs</li>
<li>Theorem 1.45 Closure Under Union</li>
<li>How to construct an NFA to recognize union (e.g. A <span class="math inline">∪</span> B)</li>
<li>Theorem 1.47 Closure under concatenation</li>
<li>How to construct an NFA to recognize concatenation (e.g. A <span class="math inline">∘</span> B)</li>
<li>Theorem 1.49 Closure under star</li>
<li>How to construct an NFA to recognize star (e.g. A<span class="math inline"><em></em><sup>*</sup></span>)</li>
<li>Notation
<ul>
<li>{ w | w is has a substring of … }</li>
<li>{ w | w is has a ends with … }</li>
<li>{ w | w is has a starts with … }</li>
<li>{ w | w is is of length… }</li>
<li>{ w | w is has has at most / at least / exactly X <span class="math inline"><em>σ</em></span>’s }</li>
<li>{ w | w has an odd/even number of <span class="math inline"><em>σ</em></span>’s}</li>
<li>{ w | w … }</li>
</ul></li>
</ul></li>
<li>1.3 Regular Expressions
<ul>
<li>Definition 1.52 Regular Expressions</li>
<li>Theorem 1.54 Regular Languages and Regular Expressions</li>
<li>Lemma 1.55 Regular Languages and Regular Expressions</li>
<li>Know how to convert a regular expression to an NFA</li>
<li>Lemma 1.60 Regular Languages and Regular Expressions</li>
<li>Definition 1.64 GNFA</li>
<li>Know how to convert an DFA to a GNFA</li>
<li>Know how to convert a GNFA to a regular expression</li>
<li>Notation
<ul>
<li><span class="math inline">∘</span></li>
<li><span class="math inline">∪</span></li>
<li><span class="math inline">*</span></li>
<li><span class="math inline"><em>Σ</em></span></li>
<li><span class="math inline"><em>ϵ</em></span></li>
<li><span class="math inline">∅</span></li>
<li>L(R)</li>
</ul></li>
<li>1.4 Nonregular languages
<ul>
<li>Know the difference between a regular and non-regular language</li>
<li>Know the relationship between non-regular languages and finite automata</li>
<li>Understand the basic premise of the Pumping Lemma: <em>if the length of a string in a regular language exceeds the number of states in its corresponding finite automaton, there must be a loop. This loop can be repeated (“pumped”) to produce other strings in the language.</em></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="some-study-tips">Some study tips</h2>
<ul>
<li>Reread Chapters 0 and 1</li>
<li>Study past homework</li>
<li>Study practice exercises</li>
<li>Study quizzes</li>
<li>Work additional problems from textbook</li>
<li>Review all notation</li>
<li>Review all theorems, definitions, corollaries, lemmas</li>
<li>Study lectures and notes</li>
<li>Master these topics
<ul>
<li>Understand the relation between NFAs, DFAs, Regular Expressions, and Regular languages</li>
<li>Be able to formally define NFAs and DFAs</li>
<li>Understand the differences between NFAs and DFAs</li>
<li>Understand how to do computation with FAs (how determine whether the machine accept or rejects a word)</li>
<li>Be able to record the sequence of states an FA goes through given an input word</li>
<li>Be able to design FAs given a language</li>
<li>Be able to draw a state diagram given a formal definition of a FA</li>
<li>Be able to construct a formal definition of an FA given a state diagram</li>
<li>Be able to define a language given an FA or a Regular Expression</li>
<li>Be familiar with the formal notation for a language</li>
</ul></li>
</ul>
</body>
</html>
